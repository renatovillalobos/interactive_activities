<html>
<head>
<style>
  body {
    margin: 0;
    padding: 0;
    width: 100vw;
    height: 100vh;
    background-color: #f0f4f8;
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: hidden;
    font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
    user-select: none;
    -webkit-user-select: none;
  }
  svg {
    width: 100%;
    height: 100%;
    max-width: 100vh; /* Keep 1:1 aspect roughly or bounded */
    max-height: 100vw;
    background: white;
    box-shadow: 0 4px 20px rgba(0,0,0,0.1);
  }
  .clickable {
    cursor: pointer;
  }
  .draggable {
    cursor: grab;
  }
  .draggable:active {
    cursor: grabbing;
  }
  .instruction-text {
    font-size: 20px;
    fill: #334155;
    text-anchor: middle;
    font-weight: 500;
  }
  .btn {
    fill: #3b82f6;
    cursor: pointer;
    transition: opacity 0.2s;
  }
  .btn:hover {
    opacity: 0.9;
  }
  .btn-text {
    fill: white;
    font-size: 16px;
    font-weight: bold;
    pointer-events: none;
    text-anchor: middle;
  }
  /* Transitions handled in JS or CSS for simple props */
  .filing {
    transition: all 1s cubic-bezier(0.25, 1, 0.5, 1);
  }
</style>
</head>
<body>

<svg viewBox="0 0 800 800" preserveAspectRatio="xMidYMid meet" id="mainSvg">
  <!-- DEFS -->
  <defs>
    <filter id="shadow" x="-20%" y="-20%" width="140%" height="140%">
      <feDropShadow dx="2" dy="4" stdDeviation="3" flood-opacity="0.2"/>
    </filter>
    <linearGradient id="magnetGrad" x1="0%" y1="0%" x2="100%" y2="0%">
      <stop offset="50%" style="stop-color:#ef4444;stop-opacity:1" />
      <stop offset="50%" style="stop-color:#3b82f6;stop-opacity:1" />
    </linearGradient>
  </defs>

  <!-- BACKGROUND TRAY -->
  <rect x="0" y="0" width="800" height="800" fill="#f8fafc" />
  
  <!-- PAPER ZONE -->
  <g id="paper-group" transform="translate(150, 200)">
    <rect x="0" y="0" width="500" height="350" fill="white" stroke="#cbd5e1" stroke-width="2" filter="url(#shadow)" />
    <!-- Drop Highlight -->
    <rect id="drop-highlight" x="10" y="10" width="480" height="330" fill="none" stroke="#3b82f6" stroke-width="2" stroke-dasharray="10,5" opacity="0" rx="10" />
  </g>

  <!-- FILINGS CONTAINER (On top of magnet usually, but magnet is placed first in logic) -->
  <!-- We put it here so it renders on top of paper, we will z-index magnet dynamically or structure carefully -->
  
  <!-- MAGNET (Draggable) Starts at bottom left -->
  <g id="magnet" class="draggable" transform="translate(50, 650)">
    <rect x="0" y="0" width="200" height="60" fill="url(#magnetGrad)" rx="4" filter="url(#shadow)"/>
    <text x="50" y="40" fill="white" font-size="30" font-weight="bold" text-anchor="middle">N</text>
    <text x="150" y="40" fill="white" font-size="30" font-weight="bold" text-anchor="middle">S</text>
  </g>

  <!-- FILINGS GROUP (Initially Empty) -->
  <!-- Transform matches the paper coordinate system approx for easier math -->
  <g id="filings-layer" transform="translate(150, 200)"></g>

  <!-- SHAKER (Clickable/Draggable tool) Starts bottom right -->
  <g id="shaker" class="clickable" transform="translate(600, 630)" opacity="0.5">
    <!-- Bottle -->
    <rect x="20" y="20" width="60" height="90" rx="5" fill="#94a3b8" stroke="#475569" stroke-width="2" />
    <!-- Lid -->
    <rect x="20" y="10" width="60" height="15" rx="2" fill="#475569" />
    <!-- Label -->
    <text x="50" y="70" fill="white" font-size="12" text-anchor="middle">Fe</text>
    <text x="50" y="85" fill="white" font-size="10" text-anchor="middle">Filings</text>
  </g>

  <!-- BUTTON: TAP (Hidden initially) -->
  <g id="tap-btn" class="clickable" transform="translate(350, 600)" opacity="0" style="pointer-events: none;">
    <rect x="0" y="0" width="100" height="40" rx="20" class="btn" />
    <text x="50" y="26" class="btn-text">TAP TRAY</text>
  </g>

  <!-- INSTRUCTIONS -->
  <text id="instruction" x="400" y="100" class="instruction-text">Drag the magnet to the center of the paper.</text>

</svg>

<script>
  // STATE
  const state = {
    magnetPlaced: false,
    sprinkled: false,
    aligned: false
  };

  // ELEMENTS
  const svg = document.getElementById('mainSvg');
  const magnet = document.getElementById('magnet');
  const shaker = document.getElementById('shaker');
  const paperGroup = document.getElementById('paper-group');
  const dropHighlight = document.getElementById('drop-highlight');
  const instruction = document.getElementById('instruction');
  const filingsLayer = document.getElementById('filings-layer');
  const tapBtn = document.getElementById('tap-btn');

  // CONSTANTS
  const PAPER_X = 150;
  const PAPER_Y = 200;
  const PAPER_W = 500;
  const PAPER_H = 350;
  
  // DRAG LOGIC VARIABLES
  let selectedElement = null;
  let offset = { x: 0, y: 0 };
  let transform = { x: 0, y: 0 };

  // UTILS
  function getMousePosition(evt) {
    const CTM = svg.getScreenCTM();
    if (evt.touches) { evt = evt.touches[0]; }
    return {
      x: (evt.clientX - CTM.e) / CTM.a,
      y: (evt.clientY - CTM.f) / CTM.d
    };
  }

  // --- MAGNET DRAG INTERACTION ---
  function startDrag(evt) {
    if (state.magnetPlaced) return; // Locked once placed
    
    // Only allow magnet dragging initially
    if (!evt.target.closest('#magnet')) return;
    
    selectedElement = magnet;
    const pos = getMousePosition(evt);
    
    // Parse current transform
    const transformStr = selectedElement.getAttribute('transform');
    const parts = /translate\(\s*([-\d.]+)\s*,\s*([-\d.]+)\s*\)/.exec(transformStr);
    transform.x = parseFloat(parts[1]);
    transform.y = parseFloat(parts[2]);
    
    offset.x = pos.x - transform.x;
    offset.y = pos.y - transform.y;
    
    // Bring to front
    svg.appendChild(selectedElement);
  }

  function drag(evt) {
    if (!selectedElement) return;
    evt.preventDefault();
    const pos = getMousePosition(evt);
    const nx = pos.x - offset.x;
    const ny = pos.y - offset.y;
    
    selectedElement.setAttribute('transform', `translate(${nx}, ${ny})`);

    // Hit test visual feedback
    // Center of magnet relative to paper
    const magCenterX = nx + 100;
    const magCenterY = ny + 30;
    
    // Check bounds of paper
    if (magCenterX > PAPER_X && magCenterX < PAPER_X + PAPER_W &&
        magCenterY > PAPER_Y && magCenterY < PAPER_Y + PAPER_H) {
      dropHighlight.setAttribute('opacity', '1');
    } else {
      dropHighlight.setAttribute('opacity', '0');
    }
  }

  function endDrag(evt) {
    if (!selectedElement) return;
    
    // Check drop
    const parts = /translate\(\s*([-\d.]+)\s*,\s*([-\d.]+)\s*\)/.exec(selectedElement.getAttribute('transform'));
    const currX = parseFloat(parts[1]);
    const currY = parseFloat(parts[2]);
    const magCenterX = currX + 100;
    const magCenterY = currY + 30;

    if (magCenterX > PAPER_X && magCenterX < PAPER_X + PAPER_W &&
        magCenterY > PAPER_Y && magCenterY < PAPER_Y + PAPER_H) {
      // SUCCESS DROP
      // Snap to center of paper (Paper center is 150+250, 200+175 => 400, 375)
      // Magnet center is 100, 30 offset
      const targetX = 400 - 100;
      const targetY = 375 - 30;
      
      selectedElement.setAttribute('transform', `translate(${targetX}, ${targetY})`);
      state.magnetPlaced = true;
      magnet.classList.remove('draggable');
      dropHighlight.setAttribute('opacity', '0');
      
      // Move magnet visually into the paper group so z-indexing works for filings later
      // We need to adjust transform to be relative to paper group (150, 200)
      // target relative: 400-150-100 = 150; 375-200-30 = 145
      paperGroup.appendChild(magnet);
      magnet.setAttribute('transform', `translate(150, 145)`);
      
      // Next Step
      instruction.textContent = "Click the shaker to sprinkle iron filings.";
      shaker.setAttribute('opacity', '1');
    } else {
      // Reset if missed
      selectedElement.setAttribute('transform', `translate(50, 650)`);
    }
    
    selectedElement = null;
  }

  // --- SHAKER INTERACTION ---
  shaker.addEventListener('click', () => {
    if (!state.magnetPlaced || state.sprinkled) return;
    
    // Animation of shaker
    let shakeCount = 0;
    const interval = setInterval(() => {
      const dx = (Math.random() - 0.5) * 10;
      const dy = (Math.random() - 0.5) * 10;
      shaker.setAttribute('transform', `translate(${600 + dx}, ${630 + dy})`);
      shakeCount++;
      
      // Generate some filings
      generateFilings(5); 

      if (shakeCount > 20) {
        clearInterval(interval);
        shaker.setAttribute('transform', `translate(600, 630)`);
        state.sprinkled = true;
        shaker.setAttribute('opacity', '0.5'); // Disable visually
        instruction.textContent = "Tap the paper to align the filings.";
        
        // Show Tap Button
        tapBtn.setAttribute('opacity', '1');
        tapBtn.style.pointerEvents = 'auto';
      }
    }, 50);
  });

  // --- FILINGS GENERATION ---
  const filings = [];
  
  function generateFilings(batchSize) {
    for (let i = 0; i < batchSize; i++) {
      const dot = document.createElementNS("http://www.w3.org/2000/svg", "rect");
      
      // Random position on paper (0-500, 0-350)
      const rx = Math.random() * 480 + 10;
      const ry = Math.random() * 330 + 10;
      
      // Random rotation
      const rot = Math.random() * 360;
      
      dot.setAttribute('x', -1.5);
      dot.setAttribute('y', -0.5);
      dot.setAttribute('width', 3);
      dot.setAttribute('height', 1);
      dot.setAttribute('fill', '#334155');
      dot.setAttribute('class', 'filing');
      dot.setAttribute('transform', `translate(${rx}, ${ry}) rotate(${rot})`);
      
      filingsLayer.appendChild(dot);
      
      // Store data for alignment
      filings.push({
        el: dot,
        currX: rx,
        currY: ry
      });
    }
  }

  // --- TAP & ALIGN LOGIC ---
  tapBtn.addEventListener('click', () => {
    if (!state.sprinkled || state.aligned) return;
    
    state.aligned = true;
    instruction.textContent = "Observe the magnetic field pattern.";
    tapBtn.setAttribute('opacity', '0');
    tapBtn.style.pointerEvents = 'none';

    alignFilings();
  });

  function alignFilings() {
    // Magnet relative position in paper group: 
    // x: 150, y: 145, w: 200, h: 60
    // Center: 250, 175
    // Poles approx: N at 180, S at 320 (relative to paper group 0,0)
    // Actually, magnet graphic: N text at x=50 (rel to magnet), S at 150.
    // Magnet x=150. So N center abs = 200, S center abs = 300. CenterY = 175.
    
    const cx = 250;
    const cy = 175;
    const poleDist = 60; // Distance from center to pole approx

    filings.forEach(f => {
      // Current pos
      let x = f.currX;
      let y = f.currY;
      
      // Basic Dipole Field approximation direction
      // Vector from N pole
      const dxN = x - (cx - poleDist);
      const dyN = y - cy;
      const rN = Math.sqrt(dxN*dxN + dyN*dyN);
      
      // Vector from S pole
      const dxS = x - (cx + poleDist);
      const dyS = y - cy;
      const rS = Math.sqrt(dxS*dxS + dyS*dyS);
      
      // Field vector B = (rN_hat / rN^2) - (rS_hat / rS^2) (Very rough prop)
      // Actually we just need the angle.
      // Angle of field at point (x,y) for a dipole.
      
      // Let's use a simpler visual trick:
      // Filings move slightly towards the lines of force.
      // Force lines are roughly ellipses passing through poles.
      
      // Calculate angle
      // B vector direction:
      const bx = (dxN / Math.pow(rN, 3)) - (dxS / Math.pow(rS, 3));
      const by = (dyN / Math.pow(rN, 3)) - (dyS / Math.pow(rS, 3));
      
      const angle = Math.atan2(by, bx) * (180 / Math.PI);
      
      // Move slightly to form chains (clustering)
      // We can nudge them towards nearest "integer" field line to create gaps
      // Field potential function V ~ 1/rN - 1/rS. 
      // We want to snap to contour lines? No, field lines flow from N to S.
      
      // Visual Hack:
      // Just rotate them to align with the field.
      // And slightly nudge them along the field vector to simulate "chaining".
      
      // Nudge amount (randomized for noise)
      const nudge = (Math.random() * 10) - 5; 
      
      // Calculate new position (move slightly along field line to clear gaps)
      // We simulate gaps by pushing away from certain zones? 
      // Simpler: Just rotation is usually enough for this level, 
      // but let's add a small displacement towards the magnet if far, 
      // or towards field line centers.
      
      // Just Rotation for "Alignment" + small random jitter to look organic
      f.el.setAttribute('transform', `translate(${x + (Math.random()*2-1)}, ${y + (Math.random()*2-1)}) rotate(${angle})`);
      
      // If inside magnet, hide or push out (Visual cleanup)
      if (x > 150 && x < 350 && y > 145 && y < 205) {
        f.el.setAttribute('opacity', 0);
      }
    });
  }

  // --- GLOBAL LISTENERS ---
  svg.addEventListener('mousedown', startDrag);
  svg.addEventListener('mousemove', drag);
  svg.addEventListener('mouseup', endDrag);
  svg.addEventListener('mouseleave', endDrag);

  svg.addEventListener('touchstart', startDrag, {passive: false});
  svg.addEventListener('touchmove', drag, {passive: false});
  svg.addEventListener('touchend', endDrag);

</script>
</body>
</html>